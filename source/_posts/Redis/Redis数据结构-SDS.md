---
title: Redis数据结构-SDS
date: 2020-06-14
categories: ['Redis']
tags: ['Redis','SDS']
comments: true
id: redisData-SDS
---

# 1. 什么是SDS

  SDS,全称是 Simple-Dynamic-String,翻译过来是<font font-weight="100" color="red" >简单动态字符串</font>,这样做的原因是，SDS是可以被<font font-weight="100" color="red" >修改</font>的。

# 2. Redis中SDS的用处。

    1. 数据库中，包含字符串的键值对在底层都是由SDS实现的。
    2. SDS可以被用作缓冲区： AOF缓存区，客户端状态中的输入缓冲区。

# 2. SDS 数据结构。

```C
  struct sdsstr {

    // 记录buf中已使用字节的数量
    // 等于SDS所保存字符串的长度
    int len;

    // 记录buf中未使用字节的数量
    int free;

    // 字节数组，用于保存字符串
    // redis 保留了C字符串结尾保留 `\0` 的的传统，这样可以直接使用C的字符串函数库
    char buf[];

  }
```

![](http://qiniu.yangrouhubo.com/markdown-img-paste-20200614181601767.png)

# 3. SDS 和 C字符串的区别

| 比较项目       | C                                                                                                                                                       | SDS                                                     |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------- |
| 获取长度       | C字符串每次需要获取字符串长度时，都需要遍历一遍字符串，复杂度是O(n)                                                                                     | SDS直接保存了字符串的长度，复杂度是O(1)                 |
| 杜绝缓存区溢出 | C语言在执行`strcat(char *dest, char *src)`函数时，用户必须确保已经为dest分配了足够的内存可以容纳src的长度，如果没有分配，则可能会影响到后面的字符串内容 | SDS在执行之这个函数的时候，已经自动为dest分配好了内存。 |
| 内存分配方式   | 每次改变长度都需要重新分配                                                                                                                              | 使用空间预分配和惰性释放的侧策略减少分配次数            |
| 二进制安全     | 使用`\0`来判断字符串的结尾，所以当存放的数据中含有        `\0`字符时，会判断字符串已经结束。                                                            | 字真正的字节数组，字符串是否结束是由长度len决定的，所以可以用它来保存一系列二进制数据。                                                        |

# 4. 减少修改字符串时，带来的内存重新分配次数。

## 4.1 C语言实现方法

  因为C字符串不记录自己的长度，所以字符串的长度总是等于存放数组的长度减去1（`\0`结尾符），正是因为这种关联性，每次增加或者减少字符串的长度时，都需要对这个数组进行内存的重新分配。

-   当字符串需要追加长度时，程序需要重新分配数组的大小，如果忘记了这一步，则可能会造成<font color='red'>内存溢出</font>。
-   当字符串需要缩短长度时，程序也需要分配数组的大小，如果忘记了这一步，则可能会造成<font color='red'>内存泄漏</font>。

## 4.2 SDS的实现方式

  内存重新设计到的算法很复杂，而且可能需要执行系统调用，所以通常会是一个比较耗时的操作。对于redis来说这是无法容忍的。为了避免这种缺陷，SDS通过<font color='red'>未使用空间 free</font>和 <font color='red'>字符串长度 len</font>解决了字符串长度对数组的依赖。数组里可以包含未使用的字节，这些字节由`free`字段进行记录。

## 4.3 未使用空间的优化策略。

  redis使用了<font color='red'>空间预分配</font>和 <font color='red'>惰性空间释放</font>两种策略来优化未使用空间。

### 4.3.1 空间预分配

当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会对SDS进行所必须空间的扩展，还会为SDS分配额外的未使用空间。具体的分配公式如下。

-   如果对SDS的修改后的长度（len的属性值）小于1M，那么程序分配和len属性同样大小的未使用空间，这时len值和free值相同。假如修改后的长度是15字节，那么程序也会分配15字节的未使用空间，即最后的数组长度为 15 + 15 + 1 = 31.
-   如果对SDS的修改后的长度（len的属性值）大于1M，那么程序分配1M的未使用空间。假如，修改后的长度为20M，那么程序会分配1M的未使用空间，即最后的数组长度是 20M + 1M + 1byte.

举例说明：
 * 我们原来的字符串HELLO是这样的：
 ![](http://qiniu.yangrouhubo.com/markdown-img-paste-20200614183021213.png)

 * 现在要在hello的后面加上‘ REDIS’。因为扩展后的长度5+6没有大于1M，所以会额外的分配11字节的未使用空间，最后的效果是这样的。
 ![](http://qiniu.yangrouhubo.com/markdown-img-paste-20200614183813619.png)

 * 如果还需要在字符串最后加上‘！’。那么这次将不再需要额外的扩容操作。如图：
 ![](http://qiniu.yangrouhubo.com/markdown-img-paste-20200614184354166.png)


通过预分配策略，如果连续进行N次的字符串扩展，SDS的从C字符串的 **固定N次** 扩展缩短为 **最多N次** 扩展。

### 4.3.2 惰性空间释放  

惰性释放用于优化SDS的缩短操作，当SDS的API对一个SDS进行修改，需要缩短SDS的长度时，程序并不会立即使用重新分配来回收多出来的字节，而是使用free属性来将这些字节的数量保存起来，并等待将来使用。于此同时，SDS也提供了API，让我们在需要时，真正的释放SDS未使用的空间。

比如：原字符串如下：
![](http://qiniu.yangrouhubo.com/markdown-img-paste-20200614184633730.png)
我们需要将后面的 ‘ REDIS!’删去，则最终的效果如下：
![](http://qiniu.yangrouhubo.com/markdown-img-paste-20200614185039753.png)
