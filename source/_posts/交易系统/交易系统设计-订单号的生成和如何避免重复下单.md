---
title: 交易系统设计-如何避免重复下单
date: 2020-05-17
categories: ['交易系统']
tags: ['订单号生成','重复下单','发号器']
comments: true
---

# 订单

订单系统作为整个交易系统中的核心，其数据准确性不言而喻。
一个常规的订单分为以下几张表
* 1 订单主表，保存订单的基本信息
* 2 商品子表，保存订单商品信息
* 3 支付子表，保存订单的支付信息
* 4 优惠子表，保存订单的优惠信息。
主表和子表之间是一对多的关系，通过订单号进行关联。

# 如何避免重复下单。

一般的订单处理请求，就是用户提交一个提交订单，发送一个Http请求到服务器，服务器生成一个订单返回给用户。 但是这个过程中，可能会由于用户多次点击提交按钮，或者网络超时重传，而生成多个订单。
那么，如何避免重复下单呢？

* 解决思路。  
  使得生成订单的过程幂等。

* 解决方法。  
 * 通过主键约束来避免重复提交。  
   服务端提供一个生成订单接口，在提交订单时，把这个订单号一并保存在数据库中，利用数据库的唯一性索引来避免重复提交。

# 如何生成订单号

* 数据库自增主键
  * 优势：简单方便
  * 缺点：性能查，以后分库分表也不好拆分。
* UUID
  * 优势：具有足够的随机性，能保障唯一
  * 缺点：
    * 没有递增性质。第一，如果需要根据时间查询一列订单并排序，则需要额外时间戳来进行排序，加大了存储成本。 第二，自增的主键在数据表插入的时候，可以减少数据的移动和分页的性能消耗。
    * 没有具体的业务含义。
    * 32个16进制组成的字符比较浪费空间
* 雪花算法（Snowflake）
  * 原理：  
    将64位的二进制数字分成若干份，每一部分都有特定的业务含义，比如 首位0 （代表正数），时间戳（41位，可供使用69年），机器ID（10位，可以拆分为机房ID和服务器Id），序列号（12位）等等。
  * 改造  
    可以对机器ID和序列号进行改造，比如分出几位代表业务ID。  
  * 缺点  
    * 依赖系统的时间戳，如果系统时间戳发生了调整（尤其是向前调整），则生成的ID会有概率发生碰撞。
    * 如果系统的并发量不高，则生成的订单最后一位永远都是1，而如果使用这个键最为分库分表的依据，则可能会造成分库分表不均匀的问题。 解决方案：时间戳不记录毫秒只记录到秒，这样在同一个时间窗口内，可以多生成几个号。 第二，起始序列号随机生成。避免了尾号重复的可能性。

# 订单号生成服务器的部署
 其实说成订单号服务器的生成，不如说成业务ID的生成。因为每个业务的ID都有和订单号一样的需求，通过改造雪花算法，在字段中假如业务字段可进行区分不同的业务。
  * 嵌入到代码中。  
    优势：不需要额外的网络调用即可生成ID  
    缺点：相当于每个服务器上的机器ID都要唯一，也就变相的要求机器码的长度了，另外，为了保证每个服务器的机器码的唯一性，需要zooKeeper进行协调。

  * 独立部署为服务器。
    和嵌入到代码中正好相反。

* 注意事项
  * 订单号最好作为自增的，防止数据库分页太多。
  * 如果提前生成订单号，则怎么避免客户端伪造订单号？ 通用的做法时，生成订单号后，返回客户端之前，同时将订单号放入Redis缓存中，在接受到生成订单的请求时，先从Redis缓存中查询是否有相应的订单号，如果有，则进行保存订单，如果没有，则返回失败。
  * 如果同时生成订单号1和订单号2，且号1和号2是有序的，但是提交订单时，号2要比号1提交的早，会导致订单号在系统中的有序性受到干扰，要怎么解决？  这块我还没想到相应的办法。



# 如何解决ABA问题。

* 什么是ABA问题。  
  假如订单中有一个状态是要填写收件人信息，用户发送请求，修改收件人信息为186****1234，然后点击保存，这时用户发现收件人信息填写错误了，就又修改为138****4567。 正常情况下，订单的收件人信息会经过两次变更，第一次变为186****1234， 第二次变成138****4567。但是如果出现网络异常或者其他原因，造成了第一次请求比第二次请求晚到，所以订单第一次变成138****4567，第二次变成168****1234。就造成了ABA问题。
* 如何避免ABA问题呢？  
  在订单信息上新增一个版本号字段，在修改订单时，同时返回订单的版本号信息，修改完成后，将修改信息和订单信息同时请求到服务器，服务器在修改订单时，判断订单的版本号是否和请求的版本号一致，如果一致则进行修改，同时修改版本号。不一致则返回失败。
  
```
  update order set order.recipient = newRecipient, version = version + 1 where order_no = orderNo and version = oldVersion

```
